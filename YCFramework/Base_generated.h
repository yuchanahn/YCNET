// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BASE_H_
#define FLATBUFFERS_GENERATED_BASE_H_

#include "flatbuffers/flatbuffers.h"

struct fping;
struct fpingT;

struct fboom;
struct fboomT;

struct fmob;
struct fmobT;

struct fout;
struct foutT;

struct fid;
struct fidT;

struct fplayer;
struct fplayerT;

struct Base;
struct BaseT;

enum eFB_Type {
	eFB_Type_Base = 0,
	eFB_Type_fping = 1,
	eFB_Type_fplayer = 2,
	eFB_Type_fid = 3,
	eFB_Type_fout = 4,
	eFB_Type_fmob = 5,
	eFB_Type_fboom = 6,
	eFB_Type_MIN = eFB_Type_Base,
	eFB_Type_MAX = eFB_Type_fboom
};

inline const eFB_Type(&EnumValueseFB_Type())[7]{
  static const eFB_Type values[] = {
	eFB_Type_Base,
	eFB_Type_fping,
	eFB_Type_fplayer,
	eFB_Type_fid,
	eFB_Type_fout,
	eFB_Type_fmob,
	eFB_Type_fboom
  };
  return values;
}

inline const char* const* EnumNameseFB_Type() {
	static const char* const names[] = {
	  "Base",
	  "fping",
	  "fplayer",
	  "fid",
	  "fout",
	  "fmob",
	  "fboom",
	  nullptr
	};
	return names;
}

inline const char* EnumNameeFB_Type(eFB_Type e) {
	const size_t index = static_cast<int>(e);
	return EnumNameseFB_Type()[index];
}

struct fpingT : public flatbuffers::NativeTable {
	typedef fping TableType;
	eFB_Type fType;
	int64_t time;
	fpingT()
		: fType(eFB_Type_Base),
		time(0) {
	}
};

struct fping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef fpingT NativeTableType;
	enum {
		VT_FTYPE = 4,
		VT_TIME = 6
	};
	eFB_Type fType() const {
		return static_cast<eFB_Type>(GetField<int32_t>(VT_FTYPE, 0));
	}
	int64_t time() const {
		return GetField<int64_t>(VT_TIME, 0);
	}
	bool Verify(flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_FTYPE) &&
			VerifyField<int64_t>(verifier, VT_TIME) &&
			verifier.EndTable();
	}
	fpingT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void UnPackTo(fpingT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static flatbuffers::Offset<fping> Pack(flatbuffers::FlatBufferBuilder& _fbb, const fpingT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct fpingBuilder {
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_fType(eFB_Type fType) {
		fbb_.AddElement<int32_t>(fping::VT_FTYPE, static_cast<int32_t>(fType), 0);
	}
	void add_time(int64_t time) {
		fbb_.AddElement<int64_t>(fping::VT_TIME, time, 0);
	}
	explicit fpingBuilder(flatbuffers::FlatBufferBuilder& _fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	fpingBuilder& operator=(const fpingBuilder&);
	flatbuffers::Offset<fping> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<fping>(end);
		return o;
	}
};

inline flatbuffers::Offset<fping> Createfping(
	flatbuffers::FlatBufferBuilder& _fbb,
	eFB_Type fType = eFB_Type_Base,
	int64_t time = 0) {
	fpingBuilder builder_(_fbb);
	builder_.add_time(time);
	builder_.add_fType(fType);
	return builder_.Finish();
}

flatbuffers::Offset<fping> Createfping(flatbuffers::FlatBufferBuilder& _fbb, const fpingT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct fboomT : public flatbuffers::NativeTable {
	typedef fboom TableType;
	eFB_Type fType;
	int32_t id;
	fboomT()
		: fType(eFB_Type_Base),
		id(0) {
	}
};

struct fboom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef fboomT NativeTableType;
	enum {
		VT_FTYPE = 4,
		VT_ID = 6
	};
	eFB_Type fType() const {
		return static_cast<eFB_Type>(GetField<int32_t>(VT_FTYPE, 0));
	}
	int32_t id() const {
		return GetField<int32_t>(VT_ID, 0);
	}
	bool Verify(flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_FTYPE) &&
			VerifyField<int32_t>(verifier, VT_ID) &&
			verifier.EndTable();
	}
	fboomT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void UnPackTo(fboomT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static flatbuffers::Offset<fboom> Pack(flatbuffers::FlatBufferBuilder& _fbb, const fboomT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct fboomBuilder {
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_fType(eFB_Type fType) {
		fbb_.AddElement<int32_t>(fboom::VT_FTYPE, static_cast<int32_t>(fType), 0);
	}
	void add_id(int32_t id) {
		fbb_.AddElement<int32_t>(fboom::VT_ID, id, 0);
	}
	explicit fboomBuilder(flatbuffers::FlatBufferBuilder& _fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	fboomBuilder& operator=(const fboomBuilder&);
	flatbuffers::Offset<fboom> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<fboom>(end);
		return o;
	}
};

inline flatbuffers::Offset<fboom> Createfboom(
	flatbuffers::FlatBufferBuilder& _fbb,
	eFB_Type fType = eFB_Type_Base,
	int32_t id = 0) {
	fboomBuilder builder_(_fbb);
	builder_.add_id(id);
	builder_.add_fType(fType);
	return builder_.Finish();
}

flatbuffers::Offset<fboom> Createfboom(flatbuffers::FlatBufferBuilder& _fbb, const fboomT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct fmobT : public flatbuffers::NativeTable {
	typedef fmob TableType;
	eFB_Type fType;
	int32_t id;
	int32_t hp;
	float x;
	float y;
	fmobT()
		: fType(eFB_Type_Base),
		id(0),
		hp(0),
		x(0.0f),
		y(0.0f) {
	}
};

struct fmob FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef fmobT NativeTableType;
	enum {
		VT_FTYPE = 4,
		VT_ID = 6,
		VT_HP = 8,
		VT_X = 10,
		VT_Y = 12
	};
	eFB_Type fType() const {
		return static_cast<eFB_Type>(GetField<int32_t>(VT_FTYPE, 0));
	}
	int32_t id() const {
		return GetField<int32_t>(VT_ID, 0);
	}
	int32_t hp() const {
		return GetField<int32_t>(VT_HP, 0);
	}
	float x() const {
		return GetField<float>(VT_X, 0.0f);
	}
	float y() const {
		return GetField<float>(VT_Y, 0.0f);
	}
	bool Verify(flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_FTYPE) &&
			VerifyField<int32_t>(verifier, VT_ID) &&
			VerifyField<int32_t>(verifier, VT_HP) &&
			VerifyField<float>(verifier, VT_X) &&
			VerifyField<float>(verifier, VT_Y) &&
			verifier.EndTable();
	}
	fmobT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void UnPackTo(fmobT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static flatbuffers::Offset<fmob> Pack(flatbuffers::FlatBufferBuilder& _fbb, const fmobT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct fmobBuilder {
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_fType(eFB_Type fType) {
		fbb_.AddElement<int32_t>(fmob::VT_FTYPE, static_cast<int32_t>(fType), 0);
	}
	void add_id(int32_t id) {
		fbb_.AddElement<int32_t>(fmob::VT_ID, id, 0);
	}
	void add_hp(int32_t hp) {
		fbb_.AddElement<int32_t>(fmob::VT_HP, hp, 0);
	}
	void add_x(float x) {
		fbb_.AddElement<float>(fmob::VT_X, x, 0.0f);
	}
	void add_y(float y) {
		fbb_.AddElement<float>(fmob::VT_Y, y, 0.0f);
	}
	explicit fmobBuilder(flatbuffers::FlatBufferBuilder& _fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	fmobBuilder& operator=(const fmobBuilder&);
	flatbuffers::Offset<fmob> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<fmob>(end);
		return o;
	}
};

inline flatbuffers::Offset<fmob> Createfmob(
	flatbuffers::FlatBufferBuilder& _fbb,
	eFB_Type fType = eFB_Type_Base,
	int32_t id = 0,
	int32_t hp = 0,
	float x = 0.0f,
	float y = 0.0f) {
	fmobBuilder builder_(_fbb);
	builder_.add_y(y);
	builder_.add_x(x);
	builder_.add_hp(hp);
	builder_.add_id(id);
	builder_.add_fType(fType);
	return builder_.Finish();
}

flatbuffers::Offset<fmob> Createfmob(flatbuffers::FlatBufferBuilder& _fbb, const fmobT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct foutT : public flatbuffers::NativeTable {
	typedef fout TableType;
	eFB_Type fType;
	int32_t id;
	foutT()
		: fType(eFB_Type_Base),
		id(0) {
	}
};

struct fout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef foutT NativeTableType;
	enum {
		VT_FTYPE = 4,
		VT_ID = 6
	};
	eFB_Type fType() const {
		return static_cast<eFB_Type>(GetField<int32_t>(VT_FTYPE, 0));
	}
	int32_t id() const {
		return GetField<int32_t>(VT_ID, 0);
	}
	bool Verify(flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_FTYPE) &&
			VerifyField<int32_t>(verifier, VT_ID) &&
			verifier.EndTable();
	}
	foutT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void UnPackTo(foutT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static flatbuffers::Offset<fout> Pack(flatbuffers::FlatBufferBuilder& _fbb, const foutT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct foutBuilder {
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_fType(eFB_Type fType) {
		fbb_.AddElement<int32_t>(fout::VT_FTYPE, static_cast<int32_t>(fType), 0);
	}
	void add_id(int32_t id) {
		fbb_.AddElement<int32_t>(fout::VT_ID, id, 0);
	}
	explicit foutBuilder(flatbuffers::FlatBufferBuilder& _fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	foutBuilder& operator=(const foutBuilder&);
	flatbuffers::Offset<fout> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<fout>(end);
		return o;
	}
};

inline flatbuffers::Offset<fout> Createfout(
	flatbuffers::FlatBufferBuilder& _fbb,
	eFB_Type fType = eFB_Type_Base,
	int32_t id = 0) {
	foutBuilder builder_(_fbb);
	builder_.add_id(id);
	builder_.add_fType(fType);
	return builder_.Finish();
}

flatbuffers::Offset<fout> Createfout(flatbuffers::FlatBufferBuilder& _fbb, const foutT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct fidT : public flatbuffers::NativeTable {
	typedef fid TableType;
	eFB_Type fType;
	int32_t id;
	fidT()
		: fType(eFB_Type_Base),
		id(0) {
	}
};

struct fid FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef fidT NativeTableType;
	enum {
		VT_FTYPE = 4,
		VT_ID = 6
	};
	eFB_Type fType() const {
		return static_cast<eFB_Type>(GetField<int32_t>(VT_FTYPE, 0));
	}
	int32_t id() const {
		return GetField<int32_t>(VT_ID, 0);
	}
	bool Verify(flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_FTYPE) &&
			VerifyField<int32_t>(verifier, VT_ID) &&
			verifier.EndTable();
	}
	fidT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void UnPackTo(fidT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static flatbuffers::Offset<fid> Pack(flatbuffers::FlatBufferBuilder& _fbb, const fidT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct fidBuilder {
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_fType(eFB_Type fType) {
		fbb_.AddElement<int32_t>(fid::VT_FTYPE, static_cast<int32_t>(fType), 0);
	}
	void add_id(int32_t id) {
		fbb_.AddElement<int32_t>(fid::VT_ID, id, 0);
	}
	explicit fidBuilder(flatbuffers::FlatBufferBuilder& _fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	fidBuilder& operator=(const fidBuilder&);
	flatbuffers::Offset<fid> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<fid>(end);
		return o;
	}
};

inline flatbuffers::Offset<fid> Createfid(
	flatbuffers::FlatBufferBuilder& _fbb,
	eFB_Type fType = eFB_Type_Base,
	int32_t id = 0) {
	fidBuilder builder_(_fbb);
	builder_.add_id(id);
	builder_.add_fType(fType);
	return builder_.Finish();
}

flatbuffers::Offset<fid> Createfid(flatbuffers::FlatBufferBuilder& _fbb, const fidT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct fplayerT : public flatbuffers::NativeTable {
	typedef fplayer TableType;
	eFB_Type fType;
	int32_t id;
	std::string name;
	int32_t hp;
	int32_t mp;
	int32_t str;
	int32_t dex;
	int32_t exp;
	int32_t lv;
	float v;
	float h;
	int32_t x;
	int32_t y;
	bool isDestroyed;
	fplayerT()
		: fType(eFB_Type_Base),
		id(0),
		hp(0),
		mp(0),
		str(0),
		dex(0),
		exp(0),
		lv(0),
		v(0.0f),
		h(0.0f),
		x(0),
		y(0),
		isDestroyed(false) {
	}
};

struct fplayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef fplayerT NativeTableType;
	enum {
		VT_FTYPE = 4,
		VT_ID = 6,
		VT_NAME = 8,
		VT_HP = 10,
		VT_MP = 12,
		VT_STR = 14,
		VT_DEX = 16,
		VT_EXP = 18,
		VT_LV = 20,
		VT_V = 22,
		VT_H = 24,
		VT_X = 26,
		VT_Y = 28,
		VT_ISDESTROYED = 30
	};
	eFB_Type fType() const {
		return static_cast<eFB_Type>(GetField<int32_t>(VT_FTYPE, 0));
	}
	int32_t id() const {
		return GetField<int32_t>(VT_ID, 0);
	}
	const flatbuffers::String* name() const {
		return GetPointer<const flatbuffers::String*>(VT_NAME);
	}
	int32_t hp() const {
		return GetField<int32_t>(VT_HP, 0);
	}
	int32_t mp() const {
		return GetField<int32_t>(VT_MP, 0);
	}
	int32_t str() const {
		return GetField<int32_t>(VT_STR, 0);
	}
	int32_t dex() const {
		return GetField<int32_t>(VT_DEX, 0);
	}
	int32_t exp() const {
		return GetField<int32_t>(VT_EXP, 0);
	}
	int32_t lv() const {
		return GetField<int32_t>(VT_LV, 0);
	}
	float v() const {
		return GetField<float>(VT_V, 0.0f);
	}
	float h() const {
		return GetField<float>(VT_H, 0.0f);
	}
	int32_t x() const {
		return GetField<int32_t>(VT_X, 0);
	}
	int32_t y() const {
		return GetField<int32_t>(VT_Y, 0);
	}
	bool isDestroyed() const {
		return GetField<uint8_t>(VT_ISDESTROYED, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_FTYPE) &&
			VerifyField<int32_t>(verifier, VT_ID) &&
			VerifyOffset(verifier, VT_NAME) &&
			verifier.Verify(name()) &&
			VerifyField<int32_t>(verifier, VT_HP) &&
			VerifyField<int32_t>(verifier, VT_MP) &&
			VerifyField<int32_t>(verifier, VT_STR) &&
			VerifyField<int32_t>(verifier, VT_DEX) &&
			VerifyField<int32_t>(verifier, VT_EXP) &&
			VerifyField<int32_t>(verifier, VT_LV) &&
			VerifyField<float>(verifier, VT_V) &&
			VerifyField<float>(verifier, VT_H) &&
			VerifyField<int32_t>(verifier, VT_X) &&
			VerifyField<int32_t>(verifier, VT_Y) &&
			VerifyField<uint8_t>(verifier, VT_ISDESTROYED) &&
			verifier.EndTable();
	}
	fplayerT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void UnPackTo(fplayerT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static flatbuffers::Offset<fplayer> Pack(flatbuffers::FlatBufferBuilder& _fbb, const fplayerT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct fplayerBuilder {
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_fType(eFB_Type fType) {
		fbb_.AddElement<int32_t>(fplayer::VT_FTYPE, static_cast<int32_t>(fType), 0);
	}
	void add_id(int32_t id) {
		fbb_.AddElement<int32_t>(fplayer::VT_ID, id, 0);
	}
	void add_name(flatbuffers::Offset<flatbuffers::String> name) {
		fbb_.AddOffset(fplayer::VT_NAME, name);
	}
	void add_hp(int32_t hp) {
		fbb_.AddElement<int32_t>(fplayer::VT_HP, hp, 0);
	}
	void add_mp(int32_t mp) {
		fbb_.AddElement<int32_t>(fplayer::VT_MP, mp, 0);
	}
	void add_str(int32_t str) {
		fbb_.AddElement<int32_t>(fplayer::VT_STR, str, 0);
	}
	void add_dex(int32_t dex) {
		fbb_.AddElement<int32_t>(fplayer::VT_DEX, dex, 0);
	}
	void add_exp(int32_t exp) {
		fbb_.AddElement<int32_t>(fplayer::VT_EXP, exp, 0);
	}
	void add_lv(int32_t lv) {
		fbb_.AddElement<int32_t>(fplayer::VT_LV, lv, 0);
	}
	void add_v(float v) {
		fbb_.AddElement<float>(fplayer::VT_V, v, 0.0f);
	}
	void add_h(float h) {
		fbb_.AddElement<float>(fplayer::VT_H, h, 0.0f);
	}
	void add_x(int32_t x) {
		fbb_.AddElement<int32_t>(fplayer::VT_X, x, 0);
	}
	void add_y(int32_t y) {
		fbb_.AddElement<int32_t>(fplayer::VT_Y, y, 0);
	}
	void add_isDestroyed(bool isDestroyed) {
		fbb_.AddElement<uint8_t>(fplayer::VT_ISDESTROYED, static_cast<uint8_t>(isDestroyed), 0);
	}
	explicit fplayerBuilder(flatbuffers::FlatBufferBuilder& _fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	fplayerBuilder& operator=(const fplayerBuilder&);
	flatbuffers::Offset<fplayer> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<fplayer>(end);
		return o;
	}
};

inline flatbuffers::Offset<fplayer> Createfplayer(
	flatbuffers::FlatBufferBuilder& _fbb,
	eFB_Type fType = eFB_Type_Base,
	int32_t id = 0,
	flatbuffers::Offset<flatbuffers::String> name = 0,
	int32_t hp = 0,
	int32_t mp = 0,
	int32_t str = 0,
	int32_t dex = 0,
	int32_t exp = 0,
	int32_t lv = 0,
	float v = 0.0f,
	float h = 0.0f,
	int32_t x = 0,
	int32_t y = 0,
	bool isDestroyed = false) {
	fplayerBuilder builder_(_fbb);
	builder_.add_y(y);
	builder_.add_x(x);
	builder_.add_h(h);
	builder_.add_v(v);
	builder_.add_lv(lv);
	builder_.add_exp(exp);
	builder_.add_dex(dex);
	builder_.add_str(str);
	builder_.add_mp(mp);
	builder_.add_hp(hp);
	builder_.add_name(name);
	builder_.add_id(id);
	builder_.add_fType(fType);
	builder_.add_isDestroyed(isDestroyed);
	return builder_.Finish();
}

inline flatbuffers::Offset<fplayer> CreatefplayerDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	eFB_Type fType = eFB_Type_Base,
	int32_t id = 0,
	const char* name = nullptr,
	int32_t hp = 0,
	int32_t mp = 0,
	int32_t str = 0,
	int32_t dex = 0,
	int32_t exp = 0,
	int32_t lv = 0,
	float v = 0.0f,
	float h = 0.0f,
	int32_t x = 0,
	int32_t y = 0,
	bool isDestroyed = false) {
	return Createfplayer(
		_fbb,
		fType,
		id,
		name ? _fbb.CreateString(name) : 0,
		hp,
		mp,
		str,
		dex,
		exp,
		lv,
		v,
		h,
		x,
		y,
		isDestroyed);
}

flatbuffers::Offset<fplayer> Createfplayer(flatbuffers::FlatBufferBuilder& _fbb, const fplayerT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct BaseT : public flatbuffers::NativeTable {
	typedef Base TableType;
	eFB_Type fType;
	BaseT()
		: fType(eFB_Type_Base) {
	}
};

struct Base FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef BaseT NativeTableType;
	enum {
		VT_FTYPE = 4
	};
	eFB_Type fType() const {
		return static_cast<eFB_Type>(GetField<int32_t>(VT_FTYPE, 0));
	}
	bool Verify(flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) &&
			VerifyField<int32_t>(verifier, VT_FTYPE) &&
			verifier.EndTable();
	}
	BaseT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void UnPackTo(BaseT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static flatbuffers::Offset<Base> Pack(flatbuffers::FlatBufferBuilder& _fbb, const BaseT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct BaseBuilder {
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_fType(eFB_Type fType) {
		fbb_.AddElement<int32_t>(Base::VT_FTYPE, static_cast<int32_t>(fType), 0);
	}
	explicit BaseBuilder(flatbuffers::FlatBufferBuilder& _fbb)
		: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	BaseBuilder& operator=(const BaseBuilder&);
	flatbuffers::Offset<Base> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Base>(end);
		return o;
	}
};

inline flatbuffers::Offset<Base> CreateBase(
	flatbuffers::FlatBufferBuilder& _fbb,
	eFB_Type fType = eFB_Type_Base) {
	BaseBuilder builder_(_fbb);
	builder_.add_fType(fType);
	return builder_.Finish();
}

flatbuffers::Offset<Base> CreateBase(flatbuffers::FlatBufferBuilder& _fbb, const BaseT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);

inline fpingT* fping::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
	auto _o = new fpingT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void fping::UnPackTo(fpingT* _o, const flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = fType(); _o->fType = _e; };
	{ auto _e = time(); _o->time = _e; };
}

inline flatbuffers::Offset<fping> fping::Pack(flatbuffers::FlatBufferBuilder& _fbb, const fpingT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	return Createfping(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<fping> Createfping(flatbuffers::FlatBufferBuilder& _fbb, const fpingT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder* __fbb; const fpingT* __o; const flatbuffers::rehasher_function_t* __rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _fType = _o->fType;
	auto _time = _o->time;
	return Createfping(
		_fbb,
		_fType,
		_time);
}

inline fboomT* fboom::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
	auto _o = new fboomT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void fboom::UnPackTo(fboomT* _o, const flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = fType(); _o->fType = _e; };
	{ auto _e = id(); _o->id = _e; };
}

inline flatbuffers::Offset<fboom> fboom::Pack(flatbuffers::FlatBufferBuilder& _fbb, const fboomT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	return Createfboom(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<fboom> Createfboom(flatbuffers::FlatBufferBuilder& _fbb, const fboomT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder* __fbb; const fboomT* __o; const flatbuffers::rehasher_function_t* __rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _fType = _o->fType;
	auto _id = _o->id;
	return Createfboom(
		_fbb,
		_fType,
		_id);
}

inline fmobT* fmob::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
	auto _o = new fmobT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void fmob::UnPackTo(fmobT* _o, const flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = fType(); _o->fType = _e; };
	{ auto _e = id(); _o->id = _e; };
	{ auto _e = hp(); _o->hp = _e; };
	{ auto _e = x(); _o->x = _e; };
	{ auto _e = y(); _o->y = _e; };
}

inline flatbuffers::Offset<fmob> fmob::Pack(flatbuffers::FlatBufferBuilder& _fbb, const fmobT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	return Createfmob(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<fmob> Createfmob(flatbuffers::FlatBufferBuilder& _fbb, const fmobT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder* __fbb; const fmobT* __o; const flatbuffers::rehasher_function_t* __rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _fType = _o->fType;
	auto _id = _o->id;
	auto _hp = _o->hp;
	auto _x = _o->x;
	auto _y = _o->y;
	return Createfmob(
		_fbb,
		_fType,
		_id,
		_hp,
		_x,
		_y);
}

inline foutT* fout::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
	auto _o = new foutT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void fout::UnPackTo(foutT* _o, const flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = fType(); _o->fType = _e; };
	{ auto _e = id(); _o->id = _e; };
}

inline flatbuffers::Offset<fout> fout::Pack(flatbuffers::FlatBufferBuilder& _fbb, const foutT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	return Createfout(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<fout> Createfout(flatbuffers::FlatBufferBuilder& _fbb, const foutT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder* __fbb; const foutT* __o; const flatbuffers::rehasher_function_t* __rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _fType = _o->fType;
	auto _id = _o->id;
	return Createfout(
		_fbb,
		_fType,
		_id);
}

inline fidT* fid::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
	auto _o = new fidT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void fid::UnPackTo(fidT* _o, const flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = fType(); _o->fType = _e; };
	{ auto _e = id(); _o->id = _e; };
}

inline flatbuffers::Offset<fid> fid::Pack(flatbuffers::FlatBufferBuilder& _fbb, const fidT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	return Createfid(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<fid> Createfid(flatbuffers::FlatBufferBuilder& _fbb, const fidT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder* __fbb; const fidT* __o; const flatbuffers::rehasher_function_t* __rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _fType = _o->fType;
	auto _id = _o->id;
	return Createfid(
		_fbb,
		_fType,
		_id);
}

inline fplayerT* fplayer::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
	auto _o = new fplayerT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void fplayer::UnPackTo(fplayerT* _o, const flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = fType(); _o->fType = _e; };
	{ auto _e = id(); _o->id = _e; };
	{ auto _e = name(); if (_e) _o->name = _e->str(); };
	{ auto _e = hp(); _o->hp = _e; };
	{ auto _e = mp(); _o->mp = _e; };
	{ auto _e = str(); _o->str = _e; };
	{ auto _e = dex(); _o->dex = _e; };
	{ auto _e = exp(); _o->exp = _e; };
	{ auto _e = lv(); _o->lv = _e; };
	{ auto _e = v(); _o->v = _e; };
	{ auto _e = h(); _o->h = _e; };
	{ auto _e = x(); _o->x = _e; };
	{ auto _e = y(); _o->y = _e; };
	{ auto _e = isDestroyed(); _o->isDestroyed = _e; };
}

inline flatbuffers::Offset<fplayer> fplayer::Pack(flatbuffers::FlatBufferBuilder& _fbb, const fplayerT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	return Createfplayer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<fplayer> Createfplayer(flatbuffers::FlatBufferBuilder& _fbb, const fplayerT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder* __fbb; const fplayerT* __o; const flatbuffers::rehasher_function_t* __rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _fType = _o->fType;
	auto _id = _o->id;
	auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
	auto _hp = _o->hp;
	auto _mp = _o->mp;
	auto _str = _o->str;
	auto _dex = _o->dex;
	auto _exp = _o->exp;
	auto _lv = _o->lv;
	auto _v = _o->v;
	auto _h = _o->h;
	auto _x = _o->x;
	auto _y = _o->y;
	auto _isDestroyed = _o->isDestroyed;
	return Createfplayer(
		_fbb,
		_fType,
		_id,
		_name,
		_hp,
		_mp,
		_str,
		_dex,
		_exp,
		_lv,
		_v,
		_h,
		_x,
		_y,
		_isDestroyed);
}

inline BaseT* Base::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
	auto _o = new BaseT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void Base::UnPackTo(BaseT* _o, const flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{ auto _e = fType(); _o->fType = _e; };
}

inline flatbuffers::Offset<Base> Base::Pack(flatbuffers::FlatBufferBuilder& _fbb, const BaseT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	return CreateBase(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Base> CreateBase(flatbuffers::FlatBufferBuilder& _fbb, const BaseT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs { flatbuffers::FlatBufferBuilder* __fbb; const BaseT* __o; const flatbuffers::rehasher_function_t* __rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
	auto _fType = _o->fType;
	return CreateBase(
		_fbb,
		_fType);
}

inline const Base* GetBase(const void* buf) {
	return flatbuffers::GetRoot<Base>(buf);
}

inline const Base* GetSizePrefixedBase(const void* buf) {
	return flatbuffers::GetSizePrefixedRoot<Base>(buf);
}

inline bool VerifyBaseBuffer(
	flatbuffers::Verifier& verifier) {
	return verifier.VerifyBuffer<Base>(nullptr);
}

inline bool VerifySizePrefixedBaseBuffer(
	flatbuffers::Verifier& verifier) {
	return verifier.VerifySizePrefixedBuffer<Base>(nullptr);
}

inline void FinishBaseBuffer(
	flatbuffers::FlatBufferBuilder& fbb,
	flatbuffers::Offset<Base> root) {
	fbb.Finish(root);
}

inline void FinishSizePrefixedBaseBuffer(
	flatbuffers::FlatBufferBuilder& fbb,
	flatbuffers::Offset<Base> root) {
	fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<BaseT> UnPackBase(
	const void* buf,
	const flatbuffers::resolver_function_t* res = nullptr) {
	return std::unique_ptr<BaseT>(GetBase(buf)->UnPack(res));
}

#endif  // FLATBUFFERS_GENERATED_BASE_H_
